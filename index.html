<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    在高处，凝望世界流动
</title>
<link rel="shortcut icon" href="https://mucixia.github.io/favicon.ico?v=1629891021928">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://mucixia.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://mucixia.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://mucixia.github.io">
                <img class="avatar" src="https://mucixia.github.io/images/avatar.png?v=1629891021928" alt="">
            </a>
            <div class="site-title">
                <h1>
                    在高处，凝望世界流动
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/jian-dan-de-ji-lu/">
                        简单的记录
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-01-15</time>
                    
                        <a href="https://mucixia.github.io/tag/tATJ1Mcio/" class="post-tag i-tag
                            i-tag-primary">
            #心情
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mucixia.github.io/post/jian-dan-de-ji-lu/" class="post-feature-image" style="background-image:url(https://mucixia.github.io/post-images/jian-dan-de-ji-lu.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                    <div class="post-content-abstract">
                                        <h4 id="写在前面周而复始-生而不息">写在前面：周而复始 生而不息</h4>

                                    </div>
                                    
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/jian-dan-de-ji-lu/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/c-yu-yan-guan-yu-shu-zu-jie-gou-zhi-zhen/">
                        C语言重难点-关于数组、结构体、递归、指针
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-18</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            一、数组
1. 定义
数组是一组相同类型元素的集合，它在内存中是连续存放的。创建方式为：
type_t arr_name [const_n] ,如：

int arr[5]
char arr[3]
double arr[10]

2.初始化：

不完全初始化：int arr[5]={1,2,3} 剩下的元素默认为0；
未指定数组长度：int arr[]={1,2,3,4}
字符串形式初始化：char arr[]=&#39;abcd&#39;

补充：sizeof和strlen
sizeof：“sizeof()”运算符求的是字符数组的长度，而不是字符串长度。只跟你给该字符串数组定义了多大空间有关，而跟字符串是否结束无关.如果遇到字符串，编译时会自动在末尾增加一个 null 字符，即char arr1[]=&#39;abc\0&#39;。
strlen：用来计算以’\0’结尾的字符串长度的函数。它并不是计算内存大小，仅计算字符串从开端到’\0’结尾字符的个数(不包含’\0’)。
char arr1[]=&#39;abc&#39;;
char arr2[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}
sizeof(arr1)=4
sizeof(arr2)=3
strlen(arr1)=3
strlen(arr2)=随机数
其中，arr1[]是字符串,arr2[]是字符数组
总结：以字符串形式出现的，编译器都会为该字符串自动添加一个0作为结束符，如在代码中写 &amp;quot;abc&amp;quot;,那么编译器帮你存储的是&amp;quot;abc/0&amp;quot;，char arr[]=&amp;quot;abc&amp;quot;实际上存储的是 char arr[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;&#39;\0}
3.二维数组
3.1 创建方式
数据类型 数组名称[行][列]，如：int arr[3][2]代表三行两列的数组
3.2 初始化

不完全初始化：int arr[3][2]={1,2,3} 剩下的元素默认为0；
1 2
3 0
0 0
指定行列：int arr[3][4]=={{1,2,3},{4,5}}
1 2 3 0
4 5 0 0
0 0 0 0

3.3 使用
访问元素：
for(int i=0;i&amp;lt;3;i++){
 for(int j=0;j&amp;lt;4;j++){
       print(&amp;quot;%d&amp;quot;,arr[i][j]);
}
     print(&amp;quot;\n&amp;quot;)
}
数组作为函数参数:
void bubble_sort(int arr[],int sz){
{
...
}
int main(){
int arr[]={1,2,3,4,5};
bubble_sort(arr,sz);//我们对arr进行传参，实际上传递过去的是数组的首元素的地址即&amp;amp;arr[0];
int sz=sizeof(arr)/sizeof(arr[0]);
...
return 0;
}
补充1：关于sizeof（arr）/sizeof(arr[0])
sizeof(arr)计算的是数组arr所占的总字节数，即空间大小；
sizeof(arr[0])是单个元素的大小；
sizeof（arr）/sizeof(arr[0])就是数组的长度；
如：int arr[]={1,2,3,4,5}
数组长度：sizeof（arr）/sizeof(arr[0])
其中，整数 int占4个字节，总字节数/4就是数组长度；
char arr[]={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}
数组长度：sizeof（arr）/sizeof(arr[0])
其字母占1个字节，故可简写成：sizeof（arr）。
补充2：&amp;amp;数组名、&amp;amp;数组名【】
&amp;amp;数组名：取出的是整个数组的地址（打印出首元素地址作为整个地址地代表）-&amp;gt;p=&amp;amp;arr,*p=arr(p是整个数组的地址，*p是数组首元素的地址)
&amp;amp;数组名[0]：取出的是数组的首元素地址
数组名：取出的是数组的首元素地址
注意：
①绝大多数时候，&amp;amp;arr[0]和arr都是首元素地址，但是也有例外：
sizeof（arr）/sizeof(arr[0])；arr表示整个数组，sizeof（arr）表示整个数组的大小。
②int arr[10]={0}

二、指针
1.1 定义
指针是编程语言中的一个对象，利用地址，它的值直接指向存在电脑存储器中的另一个地方的值，地址指向变量单元，存放地址的变量就是指针变量，换句话说，指针就是一个变量，里面存放着地址，指针就是地址。
如：
int a=10
int *p=&amp;amp;a//p是一个指针变量
prunt(*p)// *是解引用，取指针p指向的地址里的内容，*p=10
指针的大小在32位平台是四个字节，在64位平台是八个字节。
1.2 指针和指针类型
（1）指针类型的意义
①指针类型决定了指针进行解引用操作的时候，能够访问空间的大小。

int*p： *p能够访问4个字节
char *p：*p能够访问1个字节
double* p：*p能够访问8个字节
②指针类型决定了指针走一步走多远（指针的步长）
int*p： p+1--&amp;gt;往后4字节
char *p：p+1--&amp;gt;往后1字节
double* p：p+1--&amp;gt;往后8字节

（2）野指针
指针执行的位置是不可知的
导致野指针的原因：

未初始化，局部变量不初始化，默认是随机值
指针越界访问
指针指向的空间释放

怎么避免野指针：

指针初始化
小心指针越界
指针指向空间释放的话，使之置为NULL
指针使用之前检查有效性

补充：
① i++与++i
区别一：i++是右值，++i是左值，左值是可以放到赋值符号左边的变量，即具有对应的可以由用户访问的存储单元，并且能够由用户去改变其值的量，而右值i++不可以。比如说：
int i=0；
++i=1;//正确
i++=1;//错误
左值与右值的根本区别在于是否允许取地址&amp;amp;运算符获得对应的内存地址，左值允许，右值不允许。如
&amp;amp;（++i）//正确
&amp;amp; (i++) //错误
为什么++i允许，而i++不允许呢？

C/C++语言中可以放在赋值符号左边的变量，即具有对应的可以由用户访问的存储单元，并且能够由用户去改变其值的量。左值表示存储在计算机内存的对象，而不是常量或计算的结果。或者说左值是代表一个内存地址值，并且通过这个内存地址，就可以对内存进行读并且写（主要是能写）操作；这也就是为什么左值可以被赋值的原因了。相对应的还有右值：当一个符号或者常量放在操作符右边的时候，计算机就读取他们的“右值”，也就是其代表的真实值。简单来说就是，左值相当于地址值，右值相当于数据值.
区别二：i++是先运算后自加；++i是先自加后运算。比如说：
i=3
n=i++,此时，n=3，i=4（先赋值运算，后加1）
n=++i，此时，n=4，i=4（先加1，后赋值运算）

②指针+-整数
float arr[5];
float *vp；//定义一个指针变量
for (vp=&amp;amp;arr[0]; vp&amp;lt;arr[5]; ){
.    *vp++ = 0；
}
指针vp指向数组arr的首元素地址，vp++=0先赋值给vp为0，在vp+1指向第二个元素，第二个元素=0；直至第五个元素也为0.
③指针-指针（地址-地址）
必须是同类型指针
int arr[5]={1，2，3，4，5}
&amp;amp;arr[5]-&amp;amp;arr[0]=5//结果是两指针中间的元素个数
④指针比较大小
法一：
for(vp = &amp;amp;arr[5];vp&amp;gt;&amp;amp;arr[0]; ){
*--vp = 0;
}
法二：
for(vp = &amp;amp;arr[5-1];vp&amp;gt;=&amp;amp;arr[0];vp-- ){
*vp = 0;
}

但是更推荐第一种方法，标准规定：允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较即法一，不允许与指向第一个元素之前的那个内存位置的指针进行比较。
1.4 二级指针
1.4.1 定义
int a=10;
int * p1 = &amp;amp;a;//一级指针，int*分开，int表示p1指向的对象类型是int整形，*表示p1是指针
int* * p2=&amp;amp;p1//二级指针，int*表示p2指向的对象类型是int*指针即p1，右边的*表示p2是一个指针;

1.4.2 用法
解引用：
*p1=**p2=a=10
*p2=p1
1.4.3 指针与数组
#####（1）指针数组
指针数组就是存放指针的数组。
int a = 10;
int b = 20;
int c = 30;
int* pa=&amp;amp;a;
int* pb=&amp;amp;b;
int* pc=&amp;amp;c;
为了方便，我们可以将pa,pb,pc指针存放在一个数组中。
int* arr[3]={&amp;amp;a,&amp;amp;b,&amp;amp;c}
或int* arr[3]={pa，pb，pc}
遍历访问元素：
int i=0;
for(i=0;i&amp;lt;3,i++){
. *(arr[i])
}
(2)数组指针
存放数组的指针。见进阶
三、指针进阶
1.1 字符指针
1.1.1 定义
法一：
char ch = &#39;abc;
char* pc = &amp;amp;ch;
法二：
char* p = &amp;quot;abc&amp;quot;//把常量字符串“abc”的首元素a的地址放进了p中，而不是内容abc
这个严格来说应该这么写：const char* p=&amp;quot;abc&amp;quot;,理由后面介绍。
补充：字符数组和字符指针
（1）字符数组：
char arr1[4]=&amp;quot;abcd&amp;quot;
char arr2[4]=&amp;quot;abcd&amp;quot;
定义的是一个字符数组，所以就相当于定义了一些空间来存放&amp;quot;abcd&amp;quot;，而又因为字符数组就是把字符一个一个地存放的，所以编译器把这个语句解析为 char arr[5] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;\0&#39;}; 回顾之前到讲到的，sizeof(arr[5])=5; 扩展一下，如果char arr[] = &amp;quot;abcd&amp;quot;是在函数内部写的话，那么这里 的&amp;quot;abcd/0&amp;quot;因为不是常量，所以应该被放在栈上。
另外，arr1！=arr2，因为arr1，arr2分别定义了各自的空间来存储内容，这里恰巧两个的字符数组的内容一样而已。故，两者不一样。
（2）字符指针：
char* p1=&amp;quot;abcd&amp;quot;
char* p2=&amp;quot;abcd&amp;quot;
定义的是一个普通指针，并没有定义空间来存放&amp;quot;abcd&amp;quot;，所以编译器得帮我们找地方来放&amp;quot;abcd&amp;quot;，显然，把这里的&amp;quot;abcd&amp;quot;当成常量并把它放到程序 的常量区是编译器最合适的选择。拓展一下，
字符指针指向的字符串保存在内存的静态存储区中。
因为是常量字符串，如下操作：
char* p1=&amp;quot;abcd&amp;quot;
p1=“h”
错误，常量字符串不可修改。
另外，p1==p2,因为p1，p2都是常量，内容都是“abcd”，都指向同一个内存空间。
此处，为避免错误，还是写成const char p=&amp;quot;abcd&amp;quot;为好。
总结一下就是：
首先在内存的中位置不同，字符数组保存的字符串存放在内存的栈中，而字符指针指向的字符串保存在内存的静态存储区中。
其次字符数组保存的字符串属于字符串变量，可以被修改，而字符指针指向的字符串是属于字符串常量，不能被修改。
1.2 指针数组
1.2.1定义
指针数组是一个数组，用来存放指针。
int* p[10]={0}//存放整形指针的数组-指针数组
char* p[10]={0}//存放字符指针的数组-指针数组
1.2.2 使用
指针数组访问每个元素：

1.3 数组指针
数组指针是一个指针,(*p)，用来指向数组的指针。
int* p=NULL //p是整形指针-指向整型的指针-存放整形的地址
char* pc=NULL //pc是字符指针-指向字符的指针-存放字符的指针
int (*p )[10]=&amp;amp;arr //数组指针-指向数组的指针-存放数组的地址
关于数组的地址，前面有讲过，即&amp;amp;arr。
书写方法：
char* arr[5];
char* (*p)[5]=&amp;amp;arr;
int arr2[10]={0];
int (*p2)[10]=&amp;amp;arr2;

补充：关于*星号
①在定义变量时，代表着该变量是一个指针
int a=10;
int* p=&amp;amp;a;
②在取值操作时，叫解引用，即得到指针指向的地址的内容
*p=a=10
遍历方法：
int arr[10]={1,2,3,4,5,6,7,8,9,10};
int* p=arr;
int i=0;
for(i=0;i&amp;lt;10;i++){
. printf(&amp;quot;%d&amp;quot;, *(p+i))
. printf(&amp;quot;%d&amp;quot;, *(arr+i))//用指针的方法打印
. printf(&amp;quot;%d&amp;quot;, arr[i])//普通的数组打印方式
. printf(&amp;quot;%d&amp;quot;,p[i])
四种打方式结果一样
}
关于二维数组：
二维数组的数组名是首元素的地址，这里的首元素不是第一行第一列的元素，而是第一行所有的元素。（这里把二维数组理解成特殊的一维数组）
遍历二维数组的元素：
法一：
参数是数组的形式

法二（用数组指针）：
参数是指针的形式

难点：解释下为什么是*（*（p+i）+j）:



补充：
*（*（p+i）+j）的等效写法：
①（*（p+i）[j]）//备注：*（p+i）其实就是一个数组首元素的地址，用指针名[下标]找到数组某个元素。（p+i）=p[i]
②（p[i]+j）
③p[i][j]
1.4关于以上几种类型的总结
①int arr[5]//arr是一个5
个元素的整型数组
②int* parr1[10]//parr1是一个数组，数组有10个元素，每个元素的类型是int*, parr1是指针数组
③int(* parr2)[10]//parr2是一个指针，该指针指向了一个数组，该数组有10个元素，每个元素的类型是int， parr2是数组指针
④int (* parr3[10]）[5])//parr3是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素的类型是int。
1.5 数组参数
1.5.1 一维数组
（1）数组在传参的时候可以将参数写成数组，也可以写成指针。如
void test(int arr[])
{ }
void test(int arr[10])
{ }
void test(int *arr);
{ }
int main(){
int arr[10]={0};
test(arr);
}
这三种传参都是正确的。
（2）指针数组在传参的时候可以将参数写成数组，也可以写成指针。如
void test(int* arr[])//数组类型是int*
{ }
void test(int* arr[10])
{ }
void test(int** arr);
{ }
int main(){
int* arr[10]={0};
test(arr);
return 0;
}
这三种传参也是正确的。
1.5.2 二维数组
(1)数组名写法
void test (int arr[3][5]) // 写成int arr[][5],不可以写成int arr[3][],行可以省略，列不可以省略
{ }
int main(){
int arr[3][5]={0};
test(arr);
return 0;
}
（2）指针写法
①void test (int* arr)//写法错误，整形指针只存放整形，不能存放数组，而arr是二维数组的首元素地址，也就是第一行数组的地址
{ }
②void test (int** arr)//写法错误，二级指针是用来存放一级指针的地址，而arr是一个数组的地址
{ }
③void test (int* arr[5]）//写法错误，arr是一个数组，每个元素类型是int*
{ }
④void test (int（* arr)[5]）//写法正确，arr是一个指针，指向第一行数组的五个元素，类型是int
{ }
int main(){
int arr[3][5]={0};
test(arr);
return 0;
}
1.6 指针传参
1.6.1 一级指针传参
void test1(int* p)//传过来的是地址（整形指针），所以这里要用一个指针来接收
{}
int main()
{
int a=10;
&#39;test1(&amp;amp;a);//传过去的是地址
int* p=&amp;amp;a;
test1(p);//传过去的是a的地址，将a的地址存在指针变量p里面
}
1.6.2 二级指针传参
void test1(int** ptr)//传过来的是一级指针的地址，所以这里要用一个二级指针来接收
{}
int main()
{
int a=10;
int* p=&amp;amp;a;
int** pp=&amp;amp;p//pp是二级指针;
test1(pp);//传过去的是一级指针p的地址，将p的地址存在二级指针变量pp里面
test1(&amp;amp;p);
int* arr[10];//定义一个指针数组，里面存放着一级指针
test1(arr)//arr是数组首元素地址，也就是一级指针的地址
}
故，当函数的参数为二级指针得时候，参数可以是：

一级指针变量的地址
二级指针变量本身
存放一级指针的指针数组的数组名

1.7 函数指针

数组指针-指向数组的指针-存放数组的地址- int （* p）[10]
函数指针-指向函数的指针-存放函数的地址- int (* p)(in tx, int y)//函数指针类型int（* ）(int x,int y),p是一个函数声明。

使用方法：
int ADD(int x,int y)
{ ...}
int main()
{
int(* p)(int x,int y);
p(2,3);
ADD(2,3);
(*p)(2,3)
(*ADD)(2,3)
//以上四种调用函数ADD的方法都正确
//调用的时候，的数量没有用，*没有意义
}
补充：
①&amp;amp;函数名和函数名都是函数的地址
②( *( void ( * )( ) ) 0 )( )
把0强制类型转换成：void（）（）函数指针类型，0就是一个函数的地址。（*（...）0）（）调用0地址处的该函数。

③void (*signal(int , void(\*)(int) ) )( int )
signal是一个函数声明，signal的函数有2个参数，一个是int，一个是void（*）（int）函数指针，该函数指针指向的函数的参数类型是int，返回类型是void。
signal返回类型也是一个函数指针，该函数指针指向的函数的参数类型是int，返回类型是void。

该代码可以简化成：
typedef void(*pfun_t)(int);
pfun_t signal(int,pfun_t);
1.8 函数指针数组

指针数组-int* arr[5]
函数指针-int(* p)(int int)=ADD//函数指针的返回类型是int
函数指针数组-存放多个函数的地址即函数指针的地址-int (* parr[4])(int ,int)={ADD，SUB，MUL，DIV} : parr是一个数组，有四个元素，每个元素的类型是函数指针。
使用方法：


函数指针数组的用途--转移表：
计算器案列：


int main(){

}
//pfArr是一个函数指针数组，又叫转移表

1.9 指向函数指针数组的指针
1.9.1 定义

数组指针-指向数组的指针-存放数组的地址
指向函数指针的数组的指针--存放着函数指针数组的地址
int (* pf)(int , int)//函数指针
int(* pfArr[4])(int , int)//函数指针数组，pfArr是一个数组，函数指针数组
int(* (* ppfArr[4] )(int , int))//指向函数指针数组的指针，ppfArr是一个数组指针，指针指向的数组有4个元素，每个元素的类型是一个函数指针int( * )(int ， int)

1.9.2 回调函数
回调函数就是一个通过函数指针调用的函数。
解释一下就是，如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。


1.9.3 qsort函数

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/c-yu-yan-guan-yu-shu-zu-jie-gou-zhi-zhen/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/guan-yu-gridea-shu-ju-wen-zhang-biao-qian-qing-kong-de-yuan-yin-he-jie-jue-fang-fa/">
                        关于Gridea数据（文章，标签清空）的原因和解决方法
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-16</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
原因
今天我想更新一篇文章，在设置封面图的时候，选择了外链的方式打开，结果...Gridea的数据全没了，后来查明是因为在软件内填写封面图地址时，填入地址不合法，导致生成的md文件中“feature” 不合法。会导致软件无法读取数据。地址应该是url，而我用地址转换网站转换成markdown格式传上去了，就导致了后续的错误。
解决办法
找到Gridea的存储路径，我的是C:\Users\hp\Documents\Gridea，里面找到/post文件夹，然后找到你最近一次修改过的文章，,点进去将feature删除，保存后再次打开Gridea客户端即可。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/guan-yu-gridea-shu-ju-wen-zhang-biao-qian-qing-kong-de-yuan-yin-he-jie-jue-fang-fa/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/suan-fa-yu-shu-ju-jie-gou/">
                        算法与数据结构
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-16</time>
                    
                </div>
                <div class="post-article">
                    
                        <a href="https://mucixia.github.io/post/suan-fa-yu-shu-ju-jie-gou/" class="post-feature-image" style="background-image:url(https://mucixia.github.io/post-images/suan-fa-yu-shu-ju-jie-gou.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
“程序=数据结构+算法”
——Pascal语言之父-Nicklaus Wirth

一、绪论
1.1 研究内容
具体问题抽象为数学模型-&amp;gt;分析问题、提取操作对象、找出操作对象间的关系、用数学语言描述。其中，操作对象和对象间的关系也就是数据结构。如何根据关系状态来解决问题用的方法就是算法。📐📏
1.2  基本概念于术语
（1）数据
数据是能输入计算机且能被计算机处理的各种符号的集合。包括数值型数据：int、float等；非数值型数据：文字、图像、声音等。
（2）数据元素与数据项
数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理；数据项是数据元素不可分割的最小单位。比如，学生李华的姓名、学号、年龄等是一个数据元素，其中的姓名就是一个数据项。
（3）数据对象
数据对象是性质相同的****数据元素的集合，是数据集合的子集。比如整数集合，字母集合。
我画了如下一张图来表示他们之间的关系👇📣：

（4）数据结构
数据结构是带结构的数据元素的集合；结构是指数据元素之间的关系。
数据结构的分类：

逻辑结构：数据元素之间的逻辑关系
物理（存储）结构：数据元素及其关系在计算机内存中的表示（又称映像）
运算和实现：对数据元素的操作

逻辑结构和存储结构的关系：

存储结构是逻辑关系的映像与元素本身之间的映像
逻辑结构是数据结构的抽象，存储结构是数据结构的实现
两者建立了数据元素之间的结构关系
逻辑结构的种类：
线性结构：最多只有一个直接前驱和直接后继
非线性结构：可能有多个直接前驱和直接后继
存储结构的分类：
顺序存储：用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置决定的。C语言中用数组表示
链式存储：用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。
索引存储：在存储信息的同时，还建立了附加的索引表。
散列存储：根据结点的关键字直接计算出该结点的存储地址。

（5）数据类型

数据类型
包括int、float等基本数据类型，数字、结构、共用体等构造数据类型，指针。
数据类型是一组性质相同的值的集合和定义于这个值集合上的一组操作的总称。
抽象数据类型（ADT）
形式定义：（D、S、P）三元组表示，
D:数据对象； S：对象的关系集合； P：对D的基本操作集合
定义格式：
ADT 抽象数据类型名{
数据对象：定义
数据关系：定义
基本操作：定义
} ADT 抽象数据类型名
其中基本操作的定义内容为：
参数表：赋值参数，为操作提供输入值；引用参数：用连字符&amp;amp;表示，返回操作结果、
初始条件和操作结果。

概念小结：

1.3 算法与算法分析
1.3.1 算法特性：

有穷性
确定性
可行性
输入
输出

1.3.2 设计要求

正确性
可读性
健壮性
高效性

1.3.3 算法效率
算法的复杂度分析是事前估计，考虑其最坏情况，用大写O（f（n））表示。
(1)时间复杂度
算法运行时间= （语句频度）每条语句的执行次数执行时间之和
—&amp;gt;单次执行时间由机器决定，所以算法运行时间只讨论语句频度
如何计算时间复杂度：
计算规则：忽略常数、忽略系数、只取最高次项。
计算流程：算法中基本语句重复执行的次数是问题规模n的某个函数f（n），算法的时间量度记作：T(n)=O(f(n)),O(f(n))称为算法的渐进时间复杂度（O是数量级的符号），简称为时间复杂度。
首先，找到基本语句（即执行次数最多的语句），
还有关于问题规模n的函数f（n）：

排序：n为记录数
矩阵：n为矩阵的阶数
多项式：n为项数
集合：n为元素个数
树：n为树的结点个数
图：n为图的顶点数或边数
最后用O表示
计算方法：
定理一:找最高次项
例子：
for循环：嵌套几个for循环，时间复杂度就是n的多少次方
关于log2n的问题
...
常见时间复杂度：
执行常数次操作：O(1)
二分查找：O（logN）
线性查找：O（N）
归并排序、快速排序：O（NlogN）
选择排序、插入排序：O（N^2）
搜索算法：O（2^N）

二、线性表
逻辑结构分为线性结构和非线性结构，其中线性结构有线性表、栈、队列、字符串、数组、广义表等。
线性表有两种基本存储结构：顺序存储和链式存储。
1.1 线性表的定义及特点
（1）定义
线性表是具有相同特性的数据元素的有限序列,记作（a1,a2,a3, a4, a5, a6......an），其中a1为线性起点，an为线性终点，a3的直接前驱是a2，直接后继是a4；数据元素的个数n叫表长，n=0是叫空表。
(2)特点

开始节点：有且只有一个，没有直接前驱，有且只有一个直接后继
终端节点：有且只有一个，没有直接后继，有且只有一个直接前驱
中间节点：有且只有一个直接前驱，有且只有一个直接后继

（3）案例

稀疏多项式：没有包含所有x的幂的多项式
如A=7+3x+9x8+5x17
B=8x+22x7-9x8
用线性表表示：p=（系数，指数）
A=((7,0),(3,1),(9,8),(5,17))
B=((8,1),(22,7),(-9,8)
线性表运算：
先创建一个新数组C，分别遍历比较A、B里面的项：


指数相同，系数相加，其和不为零，则加到C中
指数不同，将指数较小的复制到C中
按照此方法：C=((7,0),(11,1),（22，7），(5,17))
那么，新数组的大小应该定义成多大呢？显然并不好操作。我们可以用更合适的链式存储结构来存储A+B：

还是分别遍历A，B：


1.2 线性表的类型定义

（1）基本操作
InitList（&amp;amp;L）：初始化，构造一个空的线性表L
DesyroyList（&amp;amp;L）：销毁已存在的线性表L
ClearList：清空重置已存在的线性表L
ListEmpty（L）：判断线性表是否为空，返回True或False
ListLength（L）：计算线性表的元素个数
GetElem（L，i，&amp;amp;e）：若1&amp;lt;=i&amp;lt;=ListLength(L),用e返回第i个元素
LocateElem（L，e，compare（））：compare（）为数据元素判定函数，返回第一个与e满足compare（）的数据元素
PriorElem（L，cur_e,&amp;amp;pre_e）:c当ur_e不是第一个元素时，用pre_e返回cur_e的前驱。
NextElem（L，cur_e,&amp;amp;next_e）:c当ur_e不是最后一个元素时，用next_e返回cur_e的后继。
GetElem（&amp;amp;L，i，e）：若1&amp;lt;=i&amp;lt;=ListLength(L)+1（最后一个元素的后面）,在第i个位置插入新的元素e，L的长度加1。
ListDelete（&amp;amp;L，i,&amp;amp;e）:若1&amp;lt;=i&amp;lt;=ListLength(L),删除第i个元素，并用e返回其值，L长度减1.
ListTraverse（&amp;amp;L，visited（））：遍历
1.3 线性表的顺序表示和实现
顺序表示又叫顺序存储（顺序映像）；
特点：地址连续、依次存放、随机存取、类型相同。
优点：存储密度大，随机存取任意元素
缺点：插入删除操作时，需要移动大量元素；浪费存储空间；静态存储，元素个数不可自有扩充。
定义：把逻辑上相邻的数据元素存储在物理上也相邻的存储单元中的存储结构，它占用了一片连续的储存空间。
故，可以计算出某个元素的位置。
公式：LOC（a_n）=LOC（a_m)+(n-m)*i
其中，已知第m个元素的位置和每个元素占用i个存储单元，求第n个元素的位置（n&amp;gt;m）。
若已知第一个元素，就变成了：LOC（a_n）=LOC（a1)+(n-1)*i
根据顺序表特点可用一维数组来表示：
线性表长可变--&amp;gt;用一变量表示顺序表的长度属性

注意：线性表顺序存储时的逻辑结构下标是从1开始，存储结构是从0开始的（因为存储在数组），因此，逻辑位序比物理位序多1。
1.4 顺序表基本操作的实现
（1）初始化

(2) 销毁与清空线性表

（3）线性表长度

（4）判断是否为空

（5）顺序表取位置为i的值

（6）按值查找
在线性表中查找与指定值e相同的是数据元素的位置，从表的一端与表中数据逐个比较，找到返回位置序号，未找到返回0。

平均查找长度（ASL）：
为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的平均查找长度。
简单来说，就是所有情况下的查找次数之和除以元素个数就是ASL。
ASL=∑PiCi (i=1,2,3,…,n),可以简单以数学上的期望来这么理解。其中：Pi 为查找表中第i个数据元素的概率，Ci为找到第i个数据元素时已经比较过的次数。
（7）插入算法
算法思想：

判断插入位置i是否合法（1~n+1）
判断存储空间是否已满（i&amp;lt;l.length）
将第n个位置至第i位的元素依次往后移动一个位置，空出第i个位置。
将要插入的新元素e放入第i个位置
表厂+1
插入情况：
①插入位置在最后
②插入位置在中间
③插入位置在最前面
算法实现：

算法分析：ASL=(n+...+1+0)/n+1=n/2
时间复杂度位O(n)

(8) 删除操作
删除情况：

删除位置在最后
删除位置在中间
删除位置在最前
算法思想：
①判断删除位置是否合法（1~n）
②将欲删除的元素保留在e中（可选）
③将第i个元素至第n位的元素依次向前移动一个位置
④表长-1，删除成功返回ok
算法实现：

算法分析：
ASL：
（n-1+n-2+n-3+...+0）/n=(n-1)/2
时间复杂度：
O（n）

1.5 线性表的链式表示和实现

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/suan-fa-yu-shu-ju-jie-gou/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/pa-chong-an-lie/">
                        爬虫案列
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-09</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            写在前面：
爬虫基础
python基础
爬虫案例

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/pa-chong-an-lie/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/the-road-of-python/">
                        The Road of Python
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-08</time>
                    
                        <a href="https://mucixia.github.io/tag/np7UkmaTS/" class="post-tag i-tag
                            i-tag-warning">
            #Python
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mucixia.github.io/post/the-road-of-python/" class="post-feature-image" style="background-image:url(https://mucixia.github.io/post-images/the-road-of-python.jpg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            我的python 之旅 记录与心得 - 流年的文章 - 知乎

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/the-road-of-python/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://mucixia.github.io/post/hello-gridea/">
                        Hello Gridea
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-12-12</time>
                    
                        <a href="https://mucixia.github.io/tag/CzEDw4Xfz/" class="post-tag i-tag
                            i-tag-other_3">
            #Gridea
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://mucixia.github.io/post/hello-gridea/" class="post-feature-image" style="background-image:url(https://mucixia.github.io/post-images/hello-gridea.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                    <div class="post-content-abstract">
                                        <p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>

                                    </div>
                                    
                                            <a class="btn btn-text" href="https://mucixia.github.io/post/hello-gridea/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://mucixia.github.io/images/avatar.png?v=1629891021928)">
        </div>
        <h1 class="id_card-title">
            在高处，凝望世界流动
        </h1>
        <h2 class="id_card-description">
            不必等候炬火，我便是惟一的光
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/Mucixia" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                            <!-- zhihu -->
                            
                                <a href="https://www.zhihu.com/people/liu-nian-19-58" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-zhihu"></i></a>
                                
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://mucixia.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>